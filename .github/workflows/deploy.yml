name: Build, Deploy & Smoke Test

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write
  packages: write
  actions: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE:          ${{ secrets.ACR_LOGIN_SERVER }}/moodtrack-api:${{ github.sha }}
      RESOURCE_GROUP: rg-moodtrack-dev
      CLUSTER_NAME:   aks-moodtrack-dev
      NAMESPACE:      moodtrack
      SERVICE_NAME:   moodtrack-api-svc
      TEST_USER:      alice           # utente di prova
      TEST_PASS:      wonderland

    steps:
    # 1) checkout
    - uses: actions/checkout@v4

    # 2) build & push
    - name: Build & push image
      run: |
        docker build -t "$IMAGE" .
        echo "${{ secrets.ACR_PASSWORD }}" | \
          docker login ${{ secrets.ACR_LOGIN_SERVER }} \
            -u ${{ secrets.ACR_USERNAME }} --password-stdin
        docker push "$IMAGE"

    # 3) login su Azure
    - uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # 4) se il cluster è “Stopped” lo avvio
    - name: Ensure AKS running
      run: |
        STATE=$(az aks show -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" \
                 --query powerState.code -o tsv)
        if [[ "$STATE" == "Stopped"* ]]; then
          az aks start -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME"
          az aks wait  -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --created
        else
          echo "AKS already running"
        fi

    # 5) config kubectl
    - uses: azure/aks-set-context@v3
      with:
        resource-group:    ${{ env.RESOURCE_GROUP }}
        cluster-name:      ${{ env.CLUSTER_NAME }}
        subscription-id:   ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        use-admin-credentials: true

    # 6) deploy (sostituisce l’immagine nel manifest → apply → rollout)
    - name: Deploy to AKS
      run: |
        sed -i "s|IMAGE_PLACEHOLDER|${IMAGE}|g" infra/deployment.yaml
        kubectl apply -f infra/deployment.yaml -n "$NAMESPACE"
        kubectl rollout status deployment/moodtrack-api \
          -n "$NAMESPACE" --timeout=300s

    # 7) smoke tests in un’unica shell (token + POST + GET)
    - name: Smoke tests
      run: |
        LB=$(kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" \
               -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

        echo "→ /health"
        curl -sf http://"$LB"/health >/dev/null \
          || { echo "❌ /health KO"; exit 1; }
        echo "✅ /health OK"

        echo "→ obtain JWT"
        TOKEN=$(curl -s -X POST http://"$LB"/token \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -d "username=$TEST_USER&password=$TEST_PASS" | jq -r .access_token)
        [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ] \
          || { echo "❌ token retrieval failed"; exit 1; }
        echo "✅ token OK"

        echo "→ POST /entries"
        POST_STATUS=$(curl -s -o /dev/null -w '%{http_code}' \
          -X POST http://"$LB"/entries \
          -H "Authorization: Bearer $TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"content":"smoke test entry","mood":5}')
        [ "$POST_STATUS" = "201" ] \
          || { echo "❌ POST /entries -> $POST_STATUS"; exit 1; }
        echo "✅ POST /entries OK"

        echo "→ GET /entries"
        COUNT=$(curl -s -H "Authorization: Bearer $TOKEN" \
          http://"$LB"/entries | jq 'length')
        [ "$COUNT" -ge 1 ] \
          || { echo "❌ GET /entries empty"; exit 1; }
        echo "✅ GET /entries OK ($COUNT entries)"