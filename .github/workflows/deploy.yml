name: Build, Deploy & Smoke Test

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write
  packages: write
  actions: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE:          ${{ secrets.ACR_LOGIN_SERVER }}/moodtrack-api:${{ github.sha }}
      RESOURCE_GROUP: rg-moodtrack-dev
      CLUSTER_NAME:   aks-moodtrack-dev
      NAMESPACE:      moodtrack
      SERVICE_NAME:   moodtrack-api-svc
      TEST_USER:      testuser
      TEST_PASS:      test123

    steps:
    # 1) codice
    - uses: actions/checkout@v4

    # 2) build & push
    - name: Build & push image
      run: |
        docker build -t "$IMAGE" .
        echo "${{ secrets.ACR_PASSWORD }}" | \
          docker login ${{ secrets.ACR_LOGIN_SERVER }} \
            -u ${{ secrets.ACR_USERNAME }} --password-stdin
        docker push "$IMAGE"

    # 3) login Azure
    - uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # 4) avvio cluster se fermo
    - name: Ensure AKS running
      run: |
        STATE=$(az aks show -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --query powerState.code -o tsv)
        if [[ "$STATE" == "Stopped"* ]]; then
          az aks start -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME"
          az aks wait  -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --created
        fi

    # 5) kubectl context
    - uses: azure/aks-set-context@v3
      with:
        resource-group:    ${{ env.RESOURCE_GROUP }}
        cluster-name:      ${{ env.CLUSTER_NAME }}
        subscription-id:   ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        use-admin-credentials: true

    # 6) (ri)crea i Secret applicativi
    - name: Apply K8s secrets
      run: |
        # --- JWT (SECRET_KEY + ALGORITHM) ---
        kubectl create secret generic api-secrets -n "$NAMESPACE" \
          --from-literal=SECRET_KEY='${{ secrets.SECRET_KEY }}' \
          --from-literal=ALGORITHM='${{ secrets.ALGORITHM }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        # --- SQL connection string (manifest: secret sql-conn / key url) ---
        kubectl create secret generic sql-conn -n "$NAMESPACE" \
          --from-literal=url='${{ secrets.SQL_URL }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        # --- JOB KEY per endpoint /internal/* ---
        kubectl create secret generic job-key -n "$NAMESPACE" \
          --from-literal=key='${{ secrets.JOB_KEY }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        # --- Azure OpenAI (Assistant) ---
        kubectl create secret generic aoai -n "$NAMESPACE" \
          --from-literal=endpoint='${{ secrets.AZURE_OPENAI_ENDPOINT }}' \
          --from-literal=api_key='${{ secrets.AZURE_OPENAI_API_KEY }}' \
          --from-literal=api_version='${{ secrets.AZURE_OPENAI_API_VERSION }}' \
          --from-literal=assistant_id='${{ secrets.AZURE_OPENAI_ASSISTANT_ID }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        # --- Storage connection + sentiment queue ---
        kubectl create secret generic storage-conn -n "$NAMESPACE" \
          --from-literal=conn='${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}' \
          --from-literal=sentiment_queue='${{ secrets.SENTIMENT_QUEUE }}' \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # --- App Configuration (feature flags) ---
        kubectl create secret generic appconfig-conn -n "$NAMESPACE" \
          --from-literal=connection_string='${{ secrets.APP_CONFIG_CONNECTION_STRING }}' \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # --- Application Insights (connection string) ---
        kubectl create secret generic appinsights -n "$NAMESPACE" \
          --from-literal=connection_string='${{ secrets.APPLICATIONINSIGHTS_CONNECTION_STRING }}' \
          --dry-run=client -o yaml | kubectl apply -f -
        

    # 7) deploy (sed + apply + rollout)
    - name: Deploy to AKS
      run: |
        sed -i "s|IMAGE_PLACEHOLDER|${IMAGE}|g" infra/deployment.yaml
        kubectl apply -f infra/deployment.yaml -n "$NAMESPACE"
        kubectl apply -f infra/service.yaml -n "$NAMESPACE"
        kubectl rollout status deployment/moodtrack-api -n "$NAMESPACE" --timeout=300s

    # 8) smoke-test API + chatbot + mood async
    - name: Smoke tests
      run: |
        set -euo pipefail

        # --- resolve LB (ip o hostname) ---
        LB_IP=$(kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
        LB_DNS=$(kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
        LB=${LB_IP:-$LB_DNS}
        if [ -z "$LB" ]; then
          echo "❌ LoadBalancer non pronto (niente IP/hostname)"; kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o yaml; exit 1
        fi
        BASE="http://$LB"

        echo "⌛ waiting /health @ $BASE/health"
        for i in {1..12}; do
          curl -sf "$BASE/health" && break
          [[ $i == 12 ]] && { echo "❌ /health KO"; exit 1; }
          sleep 5
        done
        echo "✅ /health OK"

        echo "→ /auth/login (JSON)"
        LOGIN_BODY=$(jq -nc --arg u "$TEST_USER" --arg p "$TEST_PASS" --arg d "ci-smoke" \
          '{username:$u,password:$p,device:$d}')
        LOGIN_JSON=$(curl -sS -f -X POST "$BASE/auth/login" \
          -H "Content-Type: application/json" \
          -d "$LOGIN_BODY") || { echo "❌ /auth/login failed"; exit 1; }

        ACCESS=$(echo "$LOGIN_JSON"  | jq -r '.access_token')
        REFRESH=$(echo "$LOGIN_JSON" | jq -r '.refresh_token')
        [ -n "$ACCESS" ]  && [ "$ACCESS"  != "null" ]  || { echo "❌ access_token mancante";  echo "$LOGIN_JSON"; exit 1; }
        [ -n "$REFRESH" ] && [ "$REFRESH" != "null" ] || { echo "❌ refresh_token mancante"; echo "$LOGIN_JSON"; exit 1; }
        echo "✅ login OK (access+refresh)"

        echo "→ POST /entries (Bearer)"
        CREATE_JSON=$(curl -sS -f -X POST "$BASE/entries" \
          -H "Authorization: Bearer $ACCESS" \
          -H "Content-Type: application/json" \
          -d '{"title":"smoke test title","content":"smoke test entry sono molto molto felice"}') \
          || { echo "❌ POST /entries failed"; exit 1; }
        echo "↪︎ create response: $CREATE_JSON"

        # Prova a leggere l'ID dal response, fallback alla lista
        ENTRY_ID=$(echo "$CREATE_JSON" | jq -r '.id // empty')
        if [ -z "$ENTRY_ID" ] || [ "$ENTRY_ID" = "null" ]; then
          echo "ℹ️ POST /entries non ha restituito id; provo dalla lista"
          # Se disponibile, prova a filtrare per titolo; altrimenti prendi il max id
          ENTRY_ID=$(curl -sS -H "Authorization: Bearer $ACCESS" "$BASE/entries" \
            | jq -r 'map(select(.title=="smoke test title")) | max_by(.id) | .id // empty')
          if [ -z "$ENTRY_ID" ] || [ "$ENTRY_ID" = "null" ]; then
            ENTRY_ID=$(curl -sS -H "Authorization: Bearer $ACCESS" "$BASE/entries" \
              | jq -r 'max_by(.id) | .id')
          fi
        fi
        [ -n "$ENTRY_ID" ] && [ "$ENTRY_ID" != "null" ] || { echo "❌ impossibile determinare ENTRY_ID"; exit 1; }
        echo "✅ POST /entries OK (id=$ENTRY_ID)"

        echo "→ GET /entries (lista base)"
        RESP=$(curl -s -H "Authorization: Bearer $ACCESS" "$BASE/entries")
        TOTAL=$(echo "$RESP" | jq '.total')
        COUNT=$(echo "$RESP" | jq '.count')
        echo "✅ GET /entries OK (total=$TOTAL, count=$COUNT)"

        echo "→ /auth/refresh (rotazione refresh)"
        REFRESH_BODY=$(jq -nc --arg r "$REFRESH" --arg d "ci-smoke" '{refresh_token:$r,device:$d}')
        REFRESH_JSON=$(curl -sS -f -X POST "$BASE/auth/refresh" \
          -H "Content-Type: application/json" \
          -d "$REFRESH_BODY") || { echo "❌ /auth/refresh failed"; exit 1; }

        NEW_ACCESS=$(echo "$REFRESH_JSON"  | jq -r '.access_token')
        NEW_REFRESH=$(echo "$REFRESH_JSON" | jq -r '.refresh_token')
        [ -n "$NEW_ACCESS" ]  && [ "$NEW_ACCESS"  != "null" ]  || { echo "❌ new access_token mancante";  echo "$REFRESH_JSON"; exit 1; }
        [ -n "$NEW_REFRESH" ] && [ "$NEW_REFRESH" != "null" ] || { echo "❌ new refresh_token mancante"; echo "$REFRESH_JSON"; exit 1; }
        echo "✅ refresh OK (token ruotato)"

        echo "→ Chatbot /chatbot/send_message con NEW_ACCESS"
        CODE_CHAT=$(curl -s -o /tmp/chat.json -w '%{http_code}' \
          -X POST "$BASE/chatbot/send_message" \
          -H "Authorization: Bearer $NEW_ACCESS" \
          -H "Content-Type: application/json" \
          -d '{"message":"Ciao, dammi un breve spunto di journaling per oggi."}')
        [ "$CODE_CHAT" = "200" ] || { echo "❌ /chatbot/send_message -> $CODE_CHAT"; cat /tmp/chat.json; exit 1; }

        THREAD_ID=$(jq -r '.thread_id' /tmp/chat.json)
        REPLY=$(jq -r '.reply' /tmp/chat.json)
        [ -n "$THREAD_ID" ] && [ "$THREAD_ID" != "null" ] || { echo "❌ thread_id mancante"; cat /tmp/chat.json; exit 1; }
        [ -n "$REPLY" ]     && [ "$REPLY"     != "null" ] || { echo "❌ reply mancante";     cat /tmp/chat.json; exit 1; }
        echo "✅ Chatbot OK (thread_id: $THREAD_ID)"
        
        echo "→ GET /chatbot/prompt_of_day"
        PROMPT_JSON=$(curl -sS -f "$BASE/chatbot/prompt_of_day" \
          -H "Authorization: Bearer $NEW_ACCESS") || { echo "❌ /chatbot/prompt_of_day failed"; exit 1; }

        ENABLED=$(echo "$PROMPT_JSON" | jq -r '.enabled')
        TEXT=$(echo "$PROMPT_JSON" | jq -r '.text // empty')
        if [ "$ENABLED" != "true" ]; then
          echo "❌ prompt_of_day.disabled -> $PROMPT_JSON"; exit 1
        fi
        if [ -z "$TEXT" ]; then
          echo "❌ prompt_of_day.text mancante -> $PROMPT_JSON"; exit 1
        fi
        echo "✅ prompt_of_day OK (text: $TEXT)"

        echo "→ Wait for async mood on entry $ENTRY_ID"
        MOOD=""
        for i in {1..18}; do  # ~3 minuti (18 * 10s)
          RESP=$(curl -s -H "Authorization: Bearer $ACCESS" "$BASE/entries/$ENTRY_ID" || true)
          CODE=$(curl -s -o /dev/null -w '%{http_code}' -H "Authorization: Bearer $ACCESS" "$BASE/entries/$ENTRY_ID")
          if [ "$CODE" = "200" ]; then
            MOOD=$(echo "$RESP" | jq -r '.mood // empty')
            if [ -n "$MOOD" ] && [ "$MOOD" != "null" ] && [ "$MOOD" -ge 1 ] && [ "$MOOD" -le 5 ]; then
              echo "✅ mood pronto per entry $ENTRY_ID: $MOOD"
              break
            fi
          fi
          echo "… mood non ancora disponibile (tentativo $i/18)"
          sleep 10
        done
        if ! [ -n "$MOOD" ] || ! [ "$MOOD" -ge 1 ] || ! [ "$MOOD" -le 5 ]; then
          echo "❌ mood non pronto entro il timeout o valore fuori range. Ultima risposta: $RESP"
          exit 1
        fi