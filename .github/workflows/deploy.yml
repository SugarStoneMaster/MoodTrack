name: Build, Deploy & Smoke Test

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write
  packages: write
  actions: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE:          ${{ secrets.ACR_LOGIN_SERVER }}/moodtrack-api:${{ github.sha }}
      RESOURCE_GROUP: rg-moodtrack-dev
      CLUSTER_NAME:   aks-moodtrack-dev
      NAMESPACE:      moodtrack
      SERVICE_NAME:   moodtrack-api-svc
      TEST_USER:      testuser
      TEST_PASS:      test123

    steps:
    # 1) codice
    - uses: actions/checkout@v4

    # 2) build & push
    - name: Build & push image
      run: |
        docker build -t "$IMAGE" .
        echo "${{ secrets.ACR_PASSWORD }}" | \
          docker login ${{ secrets.ACR_LOGIN_SERVER }} \
            -u ${{ secrets.ACR_USERNAME }} --password-stdin
        docker push "$IMAGE"

    # 3) login Azure
    - uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # 4) avvio cluster se fermo
    - name: Ensure AKS running
      run: |
        STATE=$(az aks show -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --query powerState.code -o tsv)
        if [[ "$STATE" == "Stopped"* ]]; then
          az aks start -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME"
          az aks wait  -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --created
        fi

    # 5) kubectl context
    - uses: azure/aks-set-context@v3
      with:
        resource-group:    ${{ env.RESOURCE_GROUP }}
        cluster-name:      ${{ env.CLUSTER_NAME }}
        subscription-id:   ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        use-admin-credentials: true

    # 6) (ri)crea i Secret applicativi
    - name: Apply K8s secrets
      run: |
        # --- JWT (SECRET_KEY + ALGORITHM) ---
        kubectl create secret generic api-secrets -n "$NAMESPACE" \
          --from-literal=SECRET_KEY='${{ secrets.SECRET_KEY }}' \
          --from-literal=ALGORITHM='${{ secrets.ALGORITHM }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        # --- SQL connection string (manifest: secret sql-conn / key url) ---
        kubectl create secret generic sql-conn -n "$NAMESPACE" \
          --from-literal=url='${{ secrets.SQL_URL }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        # --- JOB KEY per endpoint /internal/* ---
        kubectl create secret generic job-key -n "$NAMESPACE" \
          --from-literal=key='${{ secrets.JOB_KEY }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        # --- Azure OpenAI (Assistant) ---
        kubectl create secret generic aoai -n "$NAMESPACE" \
          --from-literal=endpoint='${{ secrets.AZURE_OPENAI_ENDPOINT }}' \
          --from-literal=api_key='${{ secrets.AZURE_OPENAI_API_KEY }}' \
          --from-literal=api_version='${{ secrets.AZURE_OPENAI_API_VERSION }}' \
          --from-literal=assistant_id='${{ secrets.AZURE_OPENAI_ASSISTANT_ID }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        # --- Storage connection for sentiment-jobs queue ---
        kubectl create secret generic storage-conn -n "$NAMESPACE" \
          --from-literal=conn='${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}' \
          --dry-run=client -o yaml | kubectl apply -f -

    # 7) deploy (sed + apply + rollout)
    - name: Deploy to AKS
      run: |
        sed -i "s|IMAGE_PLACEHOLDER|${IMAGE}|g" infra/deployment.yaml
        kubectl apply -f infra/deployment.yaml -n "$NAMESPACE"
        kubectl rollout status deployment/moodtrack-api -n "$NAMESPACE" --timeout=300s

    # 8) smoke-test API + chatbot
    - name: Smoke tests
      run: |
        LB=$(kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

        echo "⌛ waiting /health"
        for i in {1..12}; do
          curl -sf http://"$LB"/health && break
          [[ $i == 12 ]] && { echo "❌ /health KO"; exit 1; }
          sleep 5
        done
        echo "✅ /health OK"

        echo "→ obtain JWT"
        TOKEN=$(curl -s -X POST http://"$LB"/token \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -d "username=$TEST_USER&password=$TEST_PASS" | jq -r .access_token)
        [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ] || { echo "❌ token retrieval failed"; exit 1; }
        echo "✅ token OK"

        echo "→ POST /entries"
        POST=$(curl -s -o /dev/null -w '%{http_code}' \
          -X POST http://"$LB"/entries \
          -H "Authorization: Bearer $TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"content":"smoke test entry","mood":5}')
        [ "$POST" = "201" ] || { echo "❌ POST /entries -> $POST"; exit 1; }
        echo "✅ POST /entries OK"

        echo "→ GET /entries"
        LEN=$(curl -s -H "Authorization: Bearer $TOKEN" http://"$LB"/entries | jq 'length')
        [ "$LEN" -ge 1 ] || { echo "❌ GET /entries empty"; exit 1; }
        echo "✅ GET /entries OK ($LEN entries)"

        echo "→ Chatbot /chatbot/send_message"
        CODE=$(curl -s -o /tmp/chat.json -w '%{http_code}' \
          -X POST http://"$LB"/chatbot/send_message \
          -H "Authorization: Bearer $TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"message":"Ciao, dammi un breve spunto di journaling per oggi."}')
        [ "$CODE" = "200" ] || { echo "❌ /chatbot/send_message -> $CODE"; cat /tmp/chat.json; exit 1; }

        THREAD_ID=$(jq -r '.thread_id' /tmp/chat.json)
        REPLY=$(jq -r '.reply' /tmp/chat.json)

        [ -n "$THREAD_ID" ] && [ "$THREAD_ID" != "null" ] || { echo "❌ thread_id mancante"; cat /tmp/chat.json; exit 1; }
        [ -n "$REPLY" ] && [ "$REPLY" != "null" ] || { echo "❌ reply mancante"; cat /tmp/chat.json; exit 1; }
        echo "✅ Chatbot OK (thread_id: $THREAD_ID)"