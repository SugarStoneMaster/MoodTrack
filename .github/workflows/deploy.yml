name: Build, Deploy & Smoke Test

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write
  packages: write
  actions: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE:          ${{ secrets.ACR_LOGIN_SERVER }}/moodtrack-api:${{ github.sha }}
      RESOURCE_GROUP: rg-moodtrack-dev
      CLUSTER_NAME:   aks-moodtrack-dev
      NAMESPACE:      moodtrack
      RELEASE_NAME:   moodtrack-api
      SERVICE_NAME:   moodtrack-api-svc   # fissato nel chart
      TEST_USER:      testuser1
      TEST_PASS:      test123

    steps:
    - uses: actions/checkout@v4

    - name: Build & push image
      run: |
        docker build -t "$IMAGE" .
        echo "${{ secrets.ACR_PASSWORD }}" | \
          docker login ${{ secrets.ACR_LOGIN_SERVER }} \
            -u ${{ secrets.ACR_USERNAME }} --password-stdin
        docker push "$IMAGE"

    - uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Ensure AKS running
      run: |
        STATE=$(az aks show -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --query powerState.code -o tsv)
        if [[ "$STATE" == "Stopped"* ]]; then
          az aks start -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME"
          az aks wait  -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --created
        fi

    - uses: azure/aks-set-context@v3
      with:
        resource-group:    ${{ env.RESOURCE_GROUP }}
        cluster-name:      ${{ env.CLUSTER_NAME }}
        subscription-id:   ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        use-admin-credentials: true

    - name: Apply K8s secrets
      run: |
        kubectl create secret generic api-secrets -n "$NAMESPACE" \
          --from-literal=SECRET_KEY='${{ secrets.SECRET_KEY }}' \
          --from-literal=ALGORITHM='${{ secrets.ALGORITHM }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        kubectl create secret generic sql-conn -n "$NAMESPACE" \
          --from-literal=url='${{ secrets.SQL_URL }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        kubectl create secret generic job-key -n "$NAMESPACE" \
          --from-literal=key='${{ secrets.JOB_KEY }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        kubectl create secret generic aoai -n "$NAMESPACE" \
          --from-literal=endpoint='${{ secrets.AZURE_OPENAI_ENDPOINT }}' \
          --from-literal=api_key='${{ secrets.AZURE_OPENAI_API_KEY }}' \
          --from-literal=api_version='${{ secrets.AZURE_OPENAI_API_VERSION }}' \
          --from-literal=assistant_id='${{ secrets.AZURE_OPENAI_ASSISTANT_ID }}' \
          --dry-run=client -o yaml | kubectl apply -f -

        kubectl create secret generic storage-conn -n "$NAMESPACE" \
          --from-literal=conn='${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}' \
          --from-literal=sentiment_queue='${{ secrets.SENTIMENT_QUEUE }}' \
          --dry-run=client -o yaml | kubectl apply -f -
        
        kubectl create secret generic appconfig-conn -n "$NAMESPACE" \
          --from-literal=connection_string='${{ secrets.APP_CONFIG_CONNECTION_STRING }}' \
          --dry-run=client -o yaml | kubectl apply -f -
        
        kubectl create secret generic appinsights -n "$NAMESPACE" \
          --from-literal=connection_string='${{ secrets.APPLICATIONINSIGHTS_CONNECTION_STRING }}' \
          --dry-run=client -o yaml | kubectl apply -f -

    # üîß NOVIT√Ä: adotta oggetti esistenti (Service/Deployment) sotto questa release Helm
    - name: Adopt existing K8s objects into Helm release (no-downtime)
      run: |
        set -euo pipefail
        adopt() {
          local KIND="$1" NAME="$2"
          if kubectl get "$KIND" "$NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
            echo "Adopting $KIND/$NAME into Helm release $RELEASE_NAME..."
            kubectl label "$KIND" "$NAME" -n "$NAMESPACE" app.kubernetes.io/managed-by=Helm --overwrite
            kubectl annotate "$KIND" "$NAME" -n "$NAMESPACE" meta.helm.sh/release-name="$RELEASE_NAME" --overwrite
            kubectl annotate "$KIND" "$NAME" -n "$NAMESPACE" meta.helm.sh/release-namespace="$NAMESPACE" --overwrite
          else
            echo "$KIND/$NAME not found, nothing to adopt."
          fi
        }
        # Service fisso e Deployment con nome = release
        adopt service     "$SERVICE_NAME"
        adopt deployment  "$RELEASE_NAME"

    - name: Setup Helm
      uses: azure/setup-helm@v4

    - name: Deploy with Helm
      run: |
        set -euo pipefail
        helm upgrade --install "$RELEASE_NAME" ./infra/helm \
          --namespace "$NAMESPACE" --create-namespace \
          --set image.repository="${{ secrets.ACR_LOGIN_SERVER }}/moodtrack-api" \
          --set image.tag="${{ github.sha }}" \
          -f infra/helm/values-dev.yaml
        kubectl rollout status deploy/"$RELEASE_NAME" -n "$NAMESPACE" --timeout=300s

    - name: Smoke tests
      run: |
        set -euo pipefail

        LB_IP=$(kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
        LB_DNS=$(kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
        LB=${LB_IP:-$LB_DNS}
        if [ -z "$LB" ]; then
          echo "‚ùå LoadBalancer non pronto (niente IP/hostname)"; kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" -o yaml; exit 1
        fi
        BASE="http://$LB"

        echo "‚åõ waiting /health @ $BASE/health"
        for i in {1..12}; do
          curl -sf "$BASE/health" && break
          [[ $i == 12 ]] && { echo "‚ùå /health KO"; exit 1; }
          sleep 5
        done
        echo "‚úÖ /health OK"

        echo "‚Üí /auth/login (JSON)"
        LOGIN_BODY=$(jq -nc --arg u "$TEST_USER" --arg p "$TEST_PASS" --arg d "ci-smoke" \
          '{username:$u,password:$p,device:$d}')
        LOGIN_JSON=$(curl -sS -f -X POST "$BASE/auth/login" \
          -H "Content-Type: application/json" \
          -d "$LOGIN_BODY") || { echo "‚ùå /auth/login failed"; exit 1; }

        ACCESS=$(echo "$LOGIN_JSON"  | jq -r '.access_token')
        REFRESH=$(echo "$LOGIN_JSON" | jq -r '.refresh_token')
        [ -n "$ACCESS" ]  && [ "$ACCESS"  != "null" ]  || { echo "‚ùå access_token mancante";  echo "$LOGIN_JSON"; exit 1; }
        [ -n "$REFRESH" ] && [ "$REFRESH" != "null" ] || { echo "‚ùå refresh_token mancante"; echo "$LOGIN_JSON"; exit 1; }
        echo "‚úÖ login OK (access+refresh)"

        echo "‚Üí POST /entries (Bearer)"
        CREATE_JSON=$(curl -sS -f -X POST "$BASE/entries" \
          -H "Authorization: Bearer $ACCESS" \
          -H "Content-Type: application/json" \
          -d '{"title":"smoke test title","content":"smoke test entry sono molto molto felice"}') \
          || { echo "‚ùå POST /entries failed"; exit 1; }
        echo "‚Ü™Ô∏é create response: $CREATE_JSON"

        ENTRY_ID=$(echo "$CREATE_JSON" | jq -r '.id // empty')
        if [ -z "$ENTRY_ID" ] || [ "$ENTRY_ID" = "null" ]; then
          echo "‚ÑπÔ∏è POST /entries non ha restituito id; provo dalla lista"
          ENTRY_ID=$(curl -sS -H "Authorization: Bearer $ACCESS" "$BASE/entries" \
            | jq -r 'map(select(.title=="smoke test title")) | max_by(.id) | .id // empty')
          if [ -z "$ENTRY_ID" ] || [ "$ENTRY_ID" = "null" ]; then
            ENTRY_ID=$(curl -sS -H "Authorization: Bearer $ACCESS" "$BASE/entries" \
              | jq -r 'max_by(.id) | .id')
          fi
        fi
        [ -n "$ENTRY_ID" ] && [ "$ENTRY_ID" != "null" ] || { echo "‚ùå impossibile determinare ENTRY_ID"; exit 1; }
        echo "‚úÖ POST /entries OK (id=$ENTRY_ID)"

        echo "‚Üí GET /entries (lista base)"
        RESP=$(curl -s -H "Authorization: Bearer $ACCESS" "$BASE/entries")
        TOTAL=$(echo "$RESP" | jq '.total')
        COUNT=$(echo "$RESP" | jq '.count')
        echo "‚úÖ GET /entries OK (total=$TOTAL, count=$COUNT)"

        echo "‚Üí /auth/refresh (rotazione refresh)"
        REFRESH_BODY=$(jq -nc --arg r "$REFRESH" --arg d "ci-smoke" '{refresh_token:$r,device:$d}')
        REFRESH_JSON=$(curl -sS -f -X POST "$BASE/auth/refresh" \
          -H "Content-Type: application/json" \
          -d "$REFRESH_BODY") || { echo "‚ùå /auth/refresh failed"; exit 1; }

        NEW_ACCESS=$(echo "$REFRESH_JSON"  | jq -r '.access_token')
        NEW_REFRESH=$(echo "$REFRESH_JSON" | jq -r '.refresh_token')
        [ -n "$NEW_ACCESS" ]  && [ "$NEW_ACCESS"  != "null" ]  || { echo "‚ùå new access_token mancante";  echo "$REFRESH_JSON"; exit 1; }
        [ -n "$NEW_REFRESH" ] && [ "$NEW_REFRESH" != "null" ] || { echo "‚ùå new refresh_token mancante"; echo "$REFRESH_JSON"; exit 1; }
        echo "‚úÖ refresh OK (token ruotato)"

        echo "‚Üí Chatbot /chatbot/send_message con NEW_ACCESS"
        CODE_CHAT=$(curl -s -o /tmp/chat.json -w '%{http_code}' \
          -X POST "$BASE/chatbot/send_message" \
          -H "Authorization: Bearer $NEW_ACCESS" \
          -H "Content-Type: application/json" \
          -d '{"message":"Ciao, dammi un breve spunto di journaling per oggi."}')
        [ "$CODE_CHAT" = "200" ] || { echo "‚ùå /chatbot/send_message -> $CODE_CHAT"; cat /tmp/chat.json; exit 1; }

        THREAD_ID=$(jq -r '.thread_id' /tmp/chat.json)
        REPLY=$(jq -r '.reply' /tmp/chat.json)
        [ -n "$THREAD_ID" ] && [ "$THREAD_ID" != "null" ] || { echo "‚ùå thread_id mancante"; cat /tmp/chat.json; exit 1; }
        [ -n "$REPLY" ]     && [ "$REPLY"     != "null" ] || { echo "‚ùå reply mancante";     cat /tmp/chat.json; exit 1; }
        echo "‚úÖ Chatbot OK (thread_id: $THREAD_ID)"
        
        echo "‚Üí GET /chatbot/prompt_of_day"
        PROMPT_JSON=$(curl -sS -f "$BASE/chatbot/prompt_of_day" \
          -H "Authorization: Bearer $NEW_ACCESS") || { echo "‚ùå /chatbot/prompt_of_day failed"; exit 1; }

        ENABLED=$(echo "$PROMPT_JSON" | jq -r '.enabled')
        TEXT=$(echo "$PROMPT_JSON" | jq -r '.text // empty')
        if [ "$ENABLED" != "true" ]; then
          echo "‚ùå prompt_of_day.disabled -> $PROMPT_JSON"; exit 1
        fi
        if [ -z "$TEXT" ]; then
          echo "‚ùå prompt_of_day.text mancante -> $PROMPT_JSON"; exit 1
        fi
        echo "‚úÖ prompt_of_day OK (text: $TEXT)"

        echo "‚Üí Wait for async mood on entry $ENTRY_ID"
        MOOD=""
        for i in {1..18}; do  # ~3 minuti (18 * 10s)
          RESP=$(curl -s -H "Authorization: Bearer $ACCESS" "$BASE/entries/$ENTRY_ID" || true)
          CODE=$(curl -s -o /dev/null -w '%{http_code}' -H "Authorization: Bearer $ACCESS" "$BASE/entries/$ENTRY_ID")
          if [ "$CODE" = "200" ]; then
            MOOD=$(echo "$RESP" | jq -r '.mood // empty')
            if [ -n "$MOOD" ] && [ "$MOOD" != "null" ] && [ "$MOOD" -ge 1 ] && [ "$MOOD" -le 5 ]; then
              echo "‚úÖ mood pronto per entry $ENTRY_ID: $MOOD"
              break
            fi
          fi
          echo "‚Ä¶ mood non ancora disponibile (tentativo $i/18)"
          sleep 10
        done
        if ! [ -n "$MOOD" ] || ! [ "$MOOD" -ge 1 ] || ! [ "$MOOD" -le 5 ]; then
          echo "‚ùå mood non pronto entro il timeout o valore fuori range. Ultima risposta: $RESP"
          exit 1
        fi