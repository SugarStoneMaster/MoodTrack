name: Build, Deploy & Smoke Test

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write
  packages: write
  actions: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE:          ${{ secrets.ACR_LOGIN_SERVER }}/moodtrack-api:${{ github.sha }}
      RESOURCE_GROUP: rg-moodtrack-dev
      CLUSTER_NAME:   aks-moodtrack-dev
      NAMESPACE:      moodtrack
      SERVICE_NAME:   moodtrack-api-svc
      TEST_USER:      testuser
      TEST_PASS:      test123

    steps:
    # 1) codice
    - uses: actions/checkout@v4

    # 2) build & pushh
    - name: Build & push image
      run: |
        docker build -t "$IMAGE" .
        echo "${{ secrets.ACR_PASSWORD }}" | \
          docker login ${{ secrets.ACR_LOGIN_SERVER }} \
            -u ${{ secrets.ACR_USERNAME }} --password-stdin
        docker push "$IMAGE"

    # 3) login Azure
    - uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # 4) avvio cluster se fermo
    - name: Ensure AKS running
      run: |
        STATE=$(az aks show -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" \
                 --query powerState.code -o tsv)
        if [[ "$STATE" == "Stopped"* ]]; then
          az aks start -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME"
          az aks wait  -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --created
        fi

    # 5) kubectl context
    - uses: azure/aks-set-context@v3
      with:
        resource-group:    ${{ env.RESOURCE_GROUP }}
        cluster-name:      ${{ env.CLUSTER_NAME }}
        subscription-id:   ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        use-admin-credentials: true

    # 6) (ri)crea i Secret applicativi
    - name: Apply K8s secrets
      run: |
        # api-secrets (JWT)
        kubectl create secret generic api-secrets -n "$NAMESPACE" \
          --from-literal=SECRET_KEY='${{ secrets.SECRET_KEY }}' \
          --dry-run=client -o yaml | kubectl apply -f -
        # sql-url (stringa connessione)
        kubectl create secret generic sql-url -n "$NAMESPACE" \
          --from-literal=SQL_URL='${{ secrets.SQL_URL }}' \
          --dry-run=client -o yaml | kubectl apply -f -

    # 7) deploy (sed + apply + rollout)
    - name: Deploy to AKS
      run: |
        sed -i "s|IMAGE_PLACEHOLDER|${IMAGE}|g" infra/deployment.yaml
        kubectl apply -f infra/deployment.yaml -n "$NAMESPACE"
        kubectl rollout status deployment/moodtrack-api \
          -n "$NAMESPACE" --timeout=300s

    # 8) smoke-test
    - name: Smoke tests
      run: |
        LB=$(kubectl get svc "$SERVICE_NAME" -n "$NAMESPACE" \
               -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

        echo "⌛ waiting /health"
        for i in {1..12}; do
          curl -sf http://"$LB"/health && break
          [[ $i == 12 ]] && { echo "❌ /health KO"; exit 1; }
          sleep 5
        done
        echo "✅ /health OK"

        TOKEN=$(curl -s -X POST http://"$LB"/token \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -d "username=$TEST_USER&password=$TEST_PASS" | jq -r .access_token)
        [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ] \
          || { echo "❌ token retrieval failed"; exit 1; }

        POST=$(curl -s -o /dev/null -w '%{http_code}' \
          -X POST http://"$LB"/entries \
          -H "Authorization: Bearer $TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"content":"smoke test entry","mood":5}')
        [ "$POST" = "201" ] || { echo "❌ POST /entries -> $POST"; exit 1; }

        LEN=$(curl -s -H "Authorization: Bearer $TOKEN" http://"$LB"/entries | jq 'length')
        [ "$LEN" -ge 1 ] || { echo "❌ GET /entries empty"; exit 1; }

        echo "✅ Smoke-tests passed (entries: $LEN)"